<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aria | Curated IPTV Channels</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #212529;
            --muted-text-color: #6c757d;
            --border-color: #6f6f6f;
            --accent-color: #18bf90;
            --accent-hover: #3a56d4;
            --header-bg: #ffffff;
            --card-bg: #ffffff;
            --danger-color: #dc3545;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --transition: all 0.3s ease;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #121212;
                --text-color: #e9ecef;
                --muted-text-color: #adb5bd;
                --border-color: #343a40;
                --accent-color: #006de1;
                --accent-hover: #4d63d0;
                --header-bg: #1a1a1a;
                --card-bg: #1e1e1e;
                --danger-color: #f06571;
                --shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: var(--transition);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1.5rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem 0;
            background: var(--header-bg);
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin-top: 1rem;
        }

        header h1 {
            font-size: 2.8rem;
            margin: 0 0 0.5rem 0;
            background: linear-gradient(90deg, var(--accent-color), #6c8eff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }

        .tagline {
            font-size: 1.2rem;
            color: var(--muted-text-color);
            margin-bottom: 1.5rem;
        }

        .project-info {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
            border-left: 3px solid #00ff87;
            border-top: 3px solid #00ff87;
        }

        .project-info h2 {
            margin-top: 0;
            color: #00ff9f;
            font-size: 1.8rem;
        }

        .project-info h3 {
            color: #00ff9f;
            margin-top: 1.5rem;
            font-size: 1.3rem;
        }

        .project-info a {
            color: #fff;
            text-decoration: none;
            font-weight: 500;
            transition: var(--transition);
        }

        .project-info a:hover {
            color: #fff;
        }
        
        .playlist-links {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .playlist-link {
            display: flex;
            align-items: center;
            padding: 0.8rem 1.2rem;
            background-color: var(--bg-color);
            border-radius: 8px;
            text-decoration: none;
            color: var(--text-color);
            font-weight: 500;
            transition: var(--transition);
            border: 1px solid #00ff9f;
        }

        .playlist-link:hover {
            background-color: #0b6a46;
            color: white;
            border-color: #fff;
            transform: translateY(-2px);
        }

        .playlist-link i {
            margin-right: 0.5rem;
        }
        
        .search-container {
            position: relative;
            margin-bottom: 2rem;
        }

        #search-input {
            width: 100%;
            padding: 1rem 1rem 1rem 3rem;
            font-size: 1rem;
            border-radius: 50px;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: var(--text-color);
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        #search-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }

        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--muted-text-color);
        }

        .category-folder {
            border-radius: 12px;
            margin-bottom: 1.5rem;
            background-color: var(--card-bg);
            box-shadow: var(--shadow);
            overflow: hidden;
            transition: var(--transition);
        }

        .category-folder:hover {
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }

        .category-header {
            padding: 1.2rem 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 600;
            background-color: var(--header-bg);
            transition: var(--transition);
        }

        .category-header:hover {
            background-color: rgba(67, 97, 238, 0.05);
        }

        .channel-count {
            background-color: var(--accent-color);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 20px;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }

        .channel-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .channel-table th, .channel-table td {
             padding: 1rem 1.5rem;
             border-top: 1px solid var(--border-color);
             text-align: left;
             vertical-align: middle;
        }

        .channel-table th {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--muted-text-color);
            background-color: var(--header-bg);
        }
        
        .channel-name {
            display: flex;
            align-items: center;
            font-weight: 500;
            gap: 12px;
        }
        
        .channel-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            flex-shrink: 0;
            background: linear-gradient(135deg, #2e96bf, #1863f2);
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            position: relative;
        }
        
        .channel-icon-img {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .channel-icon-fallback {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        
        .channel-table a {
             color: #ff0054;
             text-decoration: none;
             font-weight: 500;
             transition: var(--transition);
        }

        .channel-table a:hover {
             color: #000;
        }

        .unstable-icon {
            color: var(--warning-color);
            margin-left: 8px;
            cursor: help;
            font-size: 1rem;
        }

        .stream-link {
            display: inline-flex;
            align-items: center;
            padding: 0.7rem 1rem;
            background-color: rgba(0, 255, 103, 0.28);
            border-radius: 150px;
            color: #ffffff;
            transition: var(--transition);
            cursor: pointer;
            border: none;
            font-family: inherit;
            font-size: inherit;
        }

        .stream-link:hover {
            background-color: #000000;
            color: white;
        }

        .stream-link.copied {
            background-color: #000000;
            color: #00ff9f;
        }

        .stream-link i {
            margin-right: 0.4rem;
            font-size: 0.9rem;
        }

        .report-button {
            display: inline-flex;
            align-items: center;
            padding: 0.5rem 1.25rem;
            border-radius: 250px;
            border: 1px solid #ff0054;
            background: transparent;
            color: var(--danger-color);
            cursor: pointer;
            text-decoration: none;
            transition: var(--transition);
            font-size: 0.9rem;
        }

        .report-button:hover {
            background-color: #ff0054;
            color: white;
        }

        .report-button i {
            margin-right: 0.4rem;
            font-size: 0.9rem;
        }

        .loading-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 3rem;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(67, 97, 238, 0.1);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--muted-text-color);
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        footer {
            text-align: center;
            margin-top: 3rem;
            padding: 2rem 0;
            color: var(--muted-text-color);
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            header h1 {
                font-size: 2.2rem;
            }
            
            .channel-table th, .channel-table td {
                padding: 0.75rem 1rem;
            }
            
            .playlist-links {
                flex-direction: column;
            }
            
            .channel-icon {
                width: 28px;
                height: 28px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            .category-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            
            .channel-table th:nth-child(2),
            .channel-table td:nth-child(2) {
                display: none;
            }
            
            .channel-icon {
                width: 24px;
                height: 24px;
                font-size: 10px;
            }
        }
    </style>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // Function to generate a channel icon based on the channel name
        const generateChannelIcon = (channelName) => {
            // Extract the first letter of each word for the icon
            const words = channelName.split(' ');
            let initials = '';
            
            if (words.length === 1) {
                initials = words[0].charAt(0).toUpperCase();
            } else {
                initials = words[0].charAt(0).toUpperCase() + words[1].charAt(0).toUpperCase();
            }
            
            return initials;
        };

        // Function to generate a color based on the channel name
        const generateIconColor = (channelName) => {
            const colors = [
                '#4361ee', '#3a0ca3', '#7209b7', '#f72585', '#4cc9f0',
                '#4895ef', '#560bad', '#b5179e', '#f15bb5', '#2ec4b6'
            ];
            
            let hash = 0;
            for (let i = 0; i < channelName.length; i++) {
                hash = channelName.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            return colors[Math.abs(hash) % colors.length];
        };

        const parseM3U = (m3uContent, isStable) => {
            const lines = m3uContent.split('\n');
            const channels = {};
            const countryRegex = /group-title="([^"]+)"/;
            const logoRegex = /tvg-logo="([^"]*)"/;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (line.startsWith('#EXTINF:-1')) {
                    try {
                        const nextLine = lines[i + 1];
                        if (!nextLine || nextLine.startsWith('#')) continue;

                        const countryMatch = line.match(countryRegex);
                        if (!countryMatch) continue;
                        
                        const country = countryMatch[1].trim();
                        const channelName = line.split(',').pop().trim();
                        const streamUrl = nextLine.trim();
                        
                        // Extract logo if available
                        const logoMatch = line.match(logoRegex);
                        const logoUrl = logoMatch && logoMatch[1] ? logoMatch[1].trim() : null;
                        
                        if (!channels[country]) channels[country] = {};
                        
                        if (!channels[country][channelName]) {
                             channels[country][channelName] = { 
                                 name: channelName, 
                                 stable: isStable, 
                                 url: streamUrl,
                                 logo: logoUrl,
                                 icon: generateChannelIcon(channelName),
                                 iconColor: generateIconColor(channelName)
                             };
                        }
                    } catch (e) { console.error("Error parsing line:", line, e); }
                }
            }
            return channels;
        };
        
        const ChannelIcon = ({ channel }) => {
            if (channel.logo) {
                return (
                    <img 
                        src={channel.logo} 
                        alt={channel.name}
                        className="channel-icon-img"
                        onError={(e) => {
                            // If image fails to load, fall back to text icon
                            e.target.style.display = 'none';
                            e.target.nextSibling.style.display = 'flex';
                        }}
                    />
                );
            }
            
            return (
                <div className="channel-icon-fallback" style={{backgroundColor: channel.iconColor}}>
                    {channel.icon}
                </div>
            );
        };
        
        const Category = ({ country, channels, forceOpen }) => {
            const [isOpen, setIsOpen] = useState(false);

            useEffect(() => {
                setIsOpen(forceOpen);
            }, [forceOpen]);

            const createReportURL = (channel) => {
                const repoUrl = "https://github.com/theariatv/theariatv.github.io/issues/new";
                const title = `Broken Stream: ${channel.name}`;
                const sourceFile = channel.stable ? 'aria.m3u' : 'aria+.m3u';
                const body = `
**Channel Name:** ${channel.name}
**Stream URL:** \`${channel.url}\`
**Source Playlist:** ${sourceFile}

**Problem:** (Please describe the issue, e.g., 'Stream does not load', 'Shows a black screen', 'Wrong content', etc.)
                `;
                return `${repoUrl}?title=${encodeURIComponent(title)}&body=${encodeURIComponent(body)}`;
            };

            return (
                <div className="category-folder">
                    <div className="category-header" onClick={() => setIsOpen(!isOpen)}>
                        <span>
                            {country}
                            <span className="channel-count">{channels.length}</span>
                        </span>
                        <span>{isOpen ? <i className="fas fa-chevron-up"></i> : <i className="fas fa-chevron-down"></i>}</span>
                    </div>
                    {isOpen && (
                        <table className="channel-table">
                           <thead>
                                <tr>
                                    <th>Channel</th>
                                    <th>Stream</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody>
                                {channels.map(channel => (
                                    <ChannelRow key={channel.name} channel={channel} createReportURL={createReportURL} />
                                ))}
                            </tbody>
                        </table>
                    )}
                </div>
            );
        };

        const ChannelRow = ({ channel, createReportURL }) => {
            const [isCopied, setIsCopied] = useState(false);
            const [showFallbackIcon, setShowFallbackIcon] = useState(!channel.logo);

            const copyToClipboard = async () => {
                try {
                    // Modern clipboard API with fallback
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(channel.url);
                    } else {
                        // Fallback for older browsers and insecure contexts
                        const textArea = document.createElement('textarea');
                        textArea.value = channel.url;
                        textArea.style.position = 'fixed';
                        textArea.style.opacity = '0';
                        document.body.appendChild(textArea);
                        textArea.select();
                        
                        const successful = document.execCommand('copy');
                        if (!successful) {
                            throw new Error('Fallback copy method failed');
                        }
                        
                        document.body.removeChild(textArea);
                    }
                    
                    setIsCopied(true);
                    setTimeout(() => setIsCopied(false), 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    // Optional: Show an error message to the user
                }
            };

            return (
                <tr>
                    <td>
                        <div className="channel-name">
                            <div className="channel-icon">
                                {!showFallbackIcon ? (
                                    <img 
                                        src={channel.logo} 
                                        alt={channel.name}
                                        className="channel-icon-img"
                                        onError={() => setShowFallbackIcon(true)}
                                    />
                                ) : null}
                                {showFallbackIcon ? (
                                    <div className="channel-icon-fallback" style={{backgroundColor: channel.iconColor}}>
                                        {channel.icon}
                                    </div>
                                ) : null}
                            </div>
                            <div>
                                {channel.name}
                                {!channel.stable && 
                                    <span className="unstable-icon" title="Potentially unstable stream from aria+.m3u">
                                        <i className="fas fa-exclamation-triangle"></i>
                                    </span>
                                }
                            </div>
                        </div>
                    </td>
                    <td>
                        <button 
                            onClick={copyToClipboard} 
                            className={`stream-link ${isCopied ? 'copied' : ''}`}
                            title="Copy stream URL to clipboard"
                        >
                            <i className={`fas ${isCopied ? 'fa-check' : 'fa-link'}`}></i> 
                            {isCopied ? 'Copied!' : 'Copy Link'}
                        </button>
                    </td>
                    <td>
                        <a href={createReportURL(channel)} target="_blank" rel="noopener noreferrer" className="report-button">
                            <i className="fas fa-flag"></i> Report
                        </a>
                    </td>
                </tr>
            );
        };

        const App = () => {
            const [allChannelData, setAllChannelData] = useState([]);
            const [filteredData, setFilteredData] = useState([]);
            const [searchTerm, setSearchTerm] = useState('');
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);

            useEffect(() => {
                const fetchAndParseData = async () => {
                    try {
                        const [ariaRes, ariaPlusRes] = await Promise.all([
                            fetch('https://aria.bnkd.xyz/aria.m3u'),
                            fetch('https://aria.bnkd.xyz/aria+.m3u')
                        ]);
                        
                        if (!ariaRes.ok) throw new Error(`Failed to fetch aria.m3u: ${ariaRes.status}`);
                        if (!ariaPlusRes.ok) throw new Error(`Failed to fetch aria+.m3u: ${ariaPlusRes.status}`);
                        
                        const [ariaText, ariaPlusText] = await Promise.all([
                            ariaRes.text(),
                            ariaPlusRes.text()
                        ]);

                        const stableChannels = parseM3U(ariaText, true);
                        const unstableChannels = parseM3U(ariaPlusText, false);

                        const allChannels = { ...stableChannels };
                        for (const country in unstableChannels) {
                            if (!allChannels[country]) allChannels[country] = {};
                            for (const channelName in unstableChannels[country]) {
                                if (!allChannels[country][channelName]) {
                                    allChannels[country][channelName] = unstableChannels[country][channelName];
                                }
                            }
                        }
                        
                        const formattedData = Object.keys(allChannels).sort().map(country => ({
                            country,
                            channels: Object.values(allChannels[country]).sort((a, b) => a.name.localeCompare(b.name))
                        }));

                        setAllChannelData(formattedData);
                        setFilteredData(formattedData);
                    } catch (error) { 
                        console.error("Could not load channel data:", error);
                        setError(error.message);
                    } finally { 
                        setLoading(false); 
                    }
                };
                fetchAndParseData();
            }, []);
            
            useEffect(() => {
                if (searchTerm === '') {
                    setFilteredData(allChannelData);
                    return;
                }
                const lowercasedFilter = searchTerm.toLowerCase();
                const filtered = allChannelData
                    .map(category => ({
                        ...category,
                        channels: category.channels.filter(channel => channel.name.toLowerCase().includes(lowercasedFilter))
                    }))
                    .filter(category => category.channels.length > 0);
                setFilteredData(filtered);
            }, [searchTerm, allChannelData]);


            return (
                <div className="container">
                    <main>
                        <div className="project-info">
                            <h2>About Aria</h2>
                            <p>
                                Aria provides a curated collection of IPTV channels from around the world. The channels are organized by their countries. Unlike our predecessor Mystique, this git is only using official streams, tvheadends, astra control panel among others. Also note the warning icons mean that the stream is in Aria+ and may be unstable.
                            </p>
                            <div className="playlist-links">
                                <a href="https://aria.bnkd.xyz/aria.m3u" download className="playlist-link">
                                    <i className="fas fa-download"></i> Download aria.m3u (Stable)
                                </a>
                                <a href="https://aria.bnkd.xyz/aria+.m3u" download className="playlist-link">
                                    <i className="fas fa-download"></i> Download aria+.m3u (Potentially Unstable)
                                </a>
                            </div>
                            <h3>Want to help us?</h3>
                            <p>
                                You can go to the <a href="https://github.com/theariatv/theariatv.github.io/issues" target="_blank" rel="noopener noreferrer">Issues tab</a> on GitHub to request a channel-specific action, or use the "Report" button next to a channel.
                            </p>
                        </div>

                        <h2>Channel List</h2>
                         <div className="search-container">
                            <i className="fas fa-search search-icon"></i>
                            <input
                                id="search-input"
                                type="search"
                                placeholder="Search for a channel..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                            />
                        </div>
                        {loading ? (
                            <div className="loading-container">
                                <div className="spinner"></div>
                            </div>
                        ) : error ? (
                            <div className="empty-state">
                                <i className="fas fa-exclamation-triangle"></i>
                                <h3>Error Loading Data</h3>
                                <p>{error}</p>
                                <p>Please check your connection and try again.</p>
                            </div>
                        ) : filteredData.length > 0 ? (
                            filteredData.map(category => (
                                <Category 
                                    key={category.country} 
                                    country={category.country} 
                                    channels={category.channels}
                                    forceOpen={searchTerm.length > 0}
                                />
                            ))
                        ) : (
                            <div className="empty-state">
                                <i className="fas fa-tv"></i>
                                <h3>No channels found</h3>
                                <p>Try adjusting your search terms</p>
                            </div>
                        )}
                    </main>
                    <footer>
                        <p>Â© {new Date().getFullYear()} Aria IPTV | Curated television streams</p>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>

</body>
</html>
